// p234-11.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
/*矩阵相乘 考虑如何使得在计算n个矩阵的乘积A1 A2…An时，总的乘法次数最小，这些矩阵的维度分别为 d0*d1，d1*d2，…，dn-1*dn。
假设所有两个矩阵的中间乘积都使用蛮力算法（基于定义）计算。

a.给出一个三个矩阵连乘的例子，当分别用(A1A2)A3和A1(A2A3)计算时，它们的乘法次数至少相差1000倍。
 答：矩阵维度A1为1000*1，A2为1*1000，A3为1000*1

 b.有多少种不同的算法来计算n个矩阵的连乘乘积？
 答：m(1)=1    m(n)=Σn-1,k=1 m(k)m(n-k)

 c.设计一个求n个矩阵乘法最优次数的动态规划算法。
*/

#include <iostream>    
using namespace std;

const int N = 7;
//p为矩阵链，p[0],p[1]代表第一个矩阵，p[1],p[2]代表第二个矩阵，length为p的长度
//所以如果有六个矩阵，length=7，m为存储最优结果的二维矩阵，s为存储选择最优结果路线的
//二维矩阵
//nXn维的辅助表m[n][n] s[n][n]分别表示最优乘积代价及其分割位置k
void MatrixChainOrder(int *p, int m[N][N], int s[N][N], int length)
{
	int n = length - 1;//矩阵个数
	int l, i, j, k, q = 0;
	//m[i][i]只有一个矩阵，所以相乘次数为0，即m[i][i]=0;
	for (i = 1; i < length; i++)
	{
		m[i][i] = 0;//对角线位置
	}
	//l表示矩阵链的长度
	// l=2时，计算 m[i,i+1],i=1,2,...,n-1 (长度l=2的链的最小代价)
	for (l = 2; l <= n; l++)//l=2为对角线紧邻的右上位置，随着l的增大，即沿着右上角的方向递增，扩大链的长度
	{
		for (i = 1; i <= n - l + 1; i++)
		{
			j = i + l - 1; //以i为起始位置，j为长度为l的链的末位，
			m[i][j] = 0x7fffffff;
			//k从i到j-1,以k为位置划分
			for (k = i; k <= j - 1; k++)
			{
				q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j];
				if (q < m[i][j])
				{
					m[i][j] = q;
					s[i][j] = k;
				}
			}
		}
	}
	cout << m[1][N - 1] << endl;
}
//以递归形式调用，添加括号，注意理解！
void PrintAnswer(int s[N][N], int i, int j)
{
	if (i == j)//只有一个矩阵，直接输出
	{
		cout << "A" << i;
	}
	/*else if(i+1==j)
	{
		cout<<"(A"<<i<<"A"<<j<<")";
	}*/
	else//是否需要再添加一种情况：两个矩阵，加括号输出？？
	{
		cout << "(";
		PrintAnswer(s, i, s[i][j]);//递归，从得到最优解的地方开始s[i][j]处断开
		PrintAnswer(s, s[i][j] + 1, j);
		cout << ")";
	}
}
int main()
{
	int p[N] = { 30,35,15,5,10,20,25 };
	int m[N][N], s[N][N];
	MatrixChainOrder(p, m, s, N);
	PrintAnswer(s, 1, N - 1);
	return 0;
}
